<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第 22 章：投机执行支持</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">AI 编译器教程：从理论到 200T 规模实践</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 1 章：AI 编译器概述</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 2 章：中间表示（IR）设计</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 3 章：计算图表示与分析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 4 章：统一缓冲区设计</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 5 章：内存规划与分配</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 6 章：数据布局优化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 7 章：算子融合</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 8 章：自动微分与梯度优化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 9 章：并行化策略</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 11 章：多维 Stride DMA 利用</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 12 章：JIT 编译技术</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 13 章：GPU 编译优化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 14 章：移动端与边缘设备优化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 15 章：NUMA 架构优化（一）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 16 章：NUMA 架构优化（二）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter17.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 17 章：动态 Shape 编译（一）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter18.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 18 章：动态 Shape 编译（二）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter19.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 19 章：稀疏与变长数据支持</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter20.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 20 章：JIT 编译技术</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter21.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 21 章：高维张量别名分析</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter22.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 22 章：投机执行支持</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter23.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 23 章：自动驾驶场景优化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter24.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 24 章：具身智能编译挑战</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter25.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 25 章：200T 模型编译实践</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="22">第 22 章：投机执行支持</h1>
<h2 id="_1">章节概览</h2>
<p>投机执行是现代 AI 系统中提升推理效率的关键技术，特别是在大语言模型的自回归生成场景中。本章深入探讨 AI 编译器如何支持投机执行，包括投机解码的编译优化、分支预测机制、回滚策略设计，以及性能与正确性的权衡。我们将从编译器的角度分析如何为投机执行提供高效的运行时支持，同时确保系统的正确性和鲁棒性。</p>
<h3 id="_2">学习目标</h3>
<p>完成本章学习后，你将能够：</p>
<ol>
<li>理解投机执行在 AI 推理中的作用机制和价值</li>
<li>掌握投机解码的编译器支持技术</li>
<li>设计高效的分支预测优化策略</li>
<li>实现可靠的回滚机制</li>
<li>权衡投机执行的性能收益与开销</li>
<li>识别并避免投机执行中的常见陷阱</li>
</ol>
<h2 id="221">22.1 投机执行基础</h2>
<h3 id="2211">22.1.1 投机执行的动机</h3>
<p>在自动驾驶和具身智能场景中，推理延迟是关键性能指标。传统的顺序执行模式在面对大规模模型时效率低下：</p>
<p>$$\text{Total_Latency} = \sum_{i=1}^{n} L_{\text{compute}}(t_i) + L_{\text{memory}}(t_i)$$
其中 $t_i$ 表示第 $i$ 个 token，$L_{\text{compute}}$ 和 $L_{\text{memory}}$ 分别表示计算和内存访问延迟。</p>
<p>投机执行通过并行处理多个可能的执行路径来隐藏延迟：
$$\text{Speculative_Latency} = \max_{\text{path}} L(\text{path}) + C_{\text{verify}} + P_{\text{rollback}} \times C_{\text{rollback}}$$
其中 $C_{\text{verify}}$ 是验证开销，$P_{\text{rollback}}$ 是回滚概率，$C_{\text{rollback}}$ 是回滚成本。</p>
<h3 id="2212">22.1.2 投机执行的类型</h3>
<p>在 AI 编译器中，主要支持三种投机执行模式：</p>
<ol>
<li><strong>Token 级投机</strong>：预测未来多个 token</li>
<li><strong>算子级投机</strong>：预测算子执行路径</li>
<li><strong>内存级投机</strong>：预取可能需要的数据</li>
</ol>
<h3 id="2213">22.1.3 编译器角色</h3>
<p>编译器在投机执行中承担以下职责：</p>
<ul>
<li><strong>静态分析</strong>：识别可投机的代码区域</li>
<li><strong>动态支持</strong>：生成支持运行时投机的代码</li>
<li><strong>资源管理</strong>：分配和管理投机执行的资源</li>
<li><strong>正确性保证</strong>：确保投机失败时的正确回滚</li>
</ul>
<h2 id="222">22.2 投机解码的编译支持</h2>
<h3 id="2221">22.2.1 投机解码原理</h3>
<p>投机解码使用小模型（draft model）快速生成候选 token 序列，然后用大模型（target model）并行验证：</p>
<div class="codehilite"><pre><span></span><code>Draft Phase:
  D₀ → d₁ → d₂ → ... → dₖ  (小模型串行生成)

Verify Phase:
  T(x, d₁, d₂, ..., dₖ) → (v₁, v₂, ..., vₘ)  (大模型并行验证)

其中 m ≤ k，表示接受的 token 数量
</code></pre></div>

<h3 id="2222">22.2.2 编译时优化</h3>
<p>编译器需要为投机解码生成特殊的执行图：</p>
<ol>
<li><strong>批处理融合</strong></li>
</ol>
<p>将多个投机 token 的计算融合到单个批次：
$$\text{Batch_Compute} = \text{fuse}([\text{compute}(t_1), \text{compute}(t_2), ..., \text{compute}(t_k)])$$</p>
<ol start="2">
<li><strong>KV Cache 管理</strong></li>
</ol>
<p>为投机执行分配专用的 KV cache 空间：</p>
<div class="codehilite"><pre><span></span><code>┌─────────────────────────────────┐
│      主 KV Cache (确定)         │
├─────────────────────────────────┤
│   投机 KV Cache (临时)          │
│   ├── Branch 1                 │
│   ├── Branch 2                 │
│   └── ...                      │
└─────────────────────────────────┘
</code></pre></div>

<ol start="3">
<li><strong>内存布局优化</strong></li>
</ol>
<p>设计支持快速回滚的内存布局：
$$\text{Memory_Layout} = \text{Base_State} \oplus \text{Delta_States}$$
其中 $\oplus$ 表示增量存储，便于快速恢复基准状态。</p>
<h3 id="2223">22.2.3 动态调度策略</h3>
<p>编译器生成的调度代码需要支持：</p>
<ol>
<li><strong>自适应投机深度</strong></li>
</ol>
<p>根据验证成功率动态调整投机深度：
$$k_{t+1} = \begin{cases}
\min(k_t + 1, k_{\max}) &amp; \text{if } \text{accept_rate} &gt; \theta_{\text{high}} \\
\max(k_t - 1, k_{\min}) &amp; \text{if } \text{accept_rate} &lt; \theta_{\text{low}} \\
k_t &amp; \text{otherwise}
\end{cases}$$</p>
<ol start="2">
<li><strong>资源分配</strong></li>
</ol>
<p>动态分配计算资源给 draft 和 target 模型：
$$\text{Resource_Draft} = \frac{R_{\text{total}}}{1 + \alpha \cdot k}$$
$$\text{Resource_Target} = R_{\text{total}} - \text{Resource_Draft}$$
其中 $\alpha$ 是资源分配系数。</p>
<h2 id="223">22.3 分支预测优化</h2>
<h3 id="2231">22.3.1 静态分支预测</h3>
<p>编译时通过程序分析预测分支概率：</p>
<ol>
<li><strong>基于模式的预测</strong></li>
</ol>
<p>识别常见的执行模式：</p>
<ul>
<li>循环边界检查：预测继续循环</li>
<li>错误处理分支：预测正常路径</li>
<li>Early stopping：基于历史统计</li>
</ul>
<ol start="2">
<li><strong>Profile-guided 优化</strong></li>
</ol>
<p>利用离线 profiling 数据：
$$P_{\text{branch}}(b) = \frac{\text{Count}_{\text{taken}}(b)}{\text{Count}_{\text{total}}(b)}$$</p>
<h3 id="2232">22.3.2 动态分支预测</h3>
<p>运行时预测机制：</p>
<ol>
<li><strong>分支历史表（BHT）</strong></li>
</ol>
<p>维护最近的分支行为历史：</p>
<div class="codehilite"><pre><span></span><code>BHT Entry:
┌──────┬──────┬──────┬──────┐
│ PC   │ Hist │ Pred │ Conf │
├──────┼──────┼──────┼──────┤
│ 0x100│ 1101 │  T   │ 0.85 │
│ 0x108│ 0011 │  F   │ 0.72 │
└──────┴──────┴──────┴──────┘
</code></pre></div>

<ol start="2">
<li><strong>两级自适应预测器</strong></li>
</ol>
<p>结合全局和局部历史：
$$\text{Prediction} = \phi(\text{Global_History}, \text{Local_History}, \text{PC})$$
其中 $\phi$ 是预测函数，通常使用感知器或简单神经网络。</p>
<h3 id="2233">22.3.3 投机路径选择</h3>
<ol>
<li><strong>置信度计算</strong></li>
</ol>
<p>为每条投机路径计算置信度：
$$\text{Confidence}(\text{path}) = \prod_{b \in \text{path}} P(b) \cdot e^{-\lambda \cdot \text{depth}}$$
其中 $\lambda$ 是深度惩罚因子。</p>
<ol start="2">
<li><strong>多路径投机</strong></li>
</ol>
<p>同时执行多条高置信度路径：</p>
<div class="codehilite"><pre><span></span><code>                 ┌─→ Path A (conf: 0.8)
    Main ───────┼─→ Path B (conf: 0.6)
                 └─→ Path C (conf: 0.4)
</code></pre></div>

<p>资源分配按置信度加权：
$$R_i = R_{\text{total}} \cdot \frac{\text{Confidence}_i}{\sum_j \text{Confidence}_j}$$</p>
<h2 id="224">22.4 回滚机制设计</h2>
<h3 id="2241">22.4.1 状态检查点</h3>
<ol>
<li><strong>完整检查点</strong></li>
</ol>
<p>保存完整的执行状态：
$$\text{Checkpoint} = \{\text{Registers}, \text{Memory}, \text{KV_Cache}, \text{Activations}\}$$</p>
<ol start="2">
<li><strong>增量检查点</strong></li>
</ol>
<p>只保存变化部分：
$$\text{Delta}_t = \text{State}_t \ominus \text{State}_{t-1}$$
其中 $\ominus$ 表示状态差分操作。</p>
<h3 id="2242">22.4.2 回滚策略</h3>
<ol>
<li><strong>立即回滚</strong></li>
</ol>
<p>检测到预测错误立即回滚：</p>
<div class="codehilite"><pre><span></span><code>if verify_failed(speculation):
    restore_checkpoint(last_valid)
    restart_from(last_valid.pc)
</code></pre></div>

<ol start="2">
<li><strong>延迟回滚</strong></li>
</ol>
<p>批量验证后统一回滚：
$$\text{Rollback_Point} = \max\{t | \forall i \leq t, \text{verify}(i) = \text{true}\}$$</p>
<h3 id="2243">22.4.3 内存一致性</h3>
<ol>
<li><strong>Write Buffer 管理</strong></li>
</ol>
<p>投机写入先缓存在专用 buffer：</p>
<div class="codehilite"><pre><span></span><code>┌────────────────┐
│  Main Memory   │
└────────────────┘
         ↑
    ┌────┴────┐
    │ Commit  │
    └────┬────┘
┌────────────────┐
│ Write Buffer   │
│ ├─ Spec Write 1│
│ ├─ Spec Write 2│
│ └─ ...         │
└────────────────┘
</code></pre></div>

<ol start="2">
<li><strong>版本化存储</strong></li>
</ol>
<p>为每个投机级别维护独立版本：
$$\text{Memory}[addr] = \begin{cases}
V_0 &amp; \text{(committed)} \\
V_1 &amp; \text{(speculation level 1)} \\
V_2 &amp; \text{(speculation level 2)} \\
\end{cases}$$</p>
<h2 id="225">22.5 性能与正确性权衡</h2>
<h3 id="2251">22.5.1 性能模型</h3>
<ol>
<li><strong>投机收益分析</strong></li>
</ol>
<p>投机执行的净收益：
$$\text{Speedup} = \frac{T_{\text{sequential}}}{T_{\text{speculative}}} = \frac{n \cdot t_{\text{seq}}}{t_{\text{draft}} + t_{\text{verify}} + P_{\text{miss}} \cdot t_{\text{rollback}}}$$</p>
<ol start="2">
<li><strong>最优投机深度</strong></li>
</ol>
<p>求解最优投机深度 $k^*$：
$$k^* = \arg\max_k \left[ \frac{k \cdot p^k}{t_{\text{draft}}(k) + t_{\text{verify}}(k)} \right]$$
其中 $p$ 是单步预测准确率。</p>
<h3 id="2252">22.5.2 正确性保证</h3>
<ol>
<li><strong>语义等价性</strong></li>
</ol>
<p>确保投机执行结果与顺序执行一致：
$$\forall \text{input}, \text{Spec_Exec}(\text{input}) \equiv \text{Seq_Exec}(\text{input})$$</p>
<ol start="2">
<li><strong>异常处理</strong></li>
</ol>
<p>投机执行中的异常必须正确处理：</p>
<div class="codehilite"><pre><span></span><code>Exception Handling:

1. 投机路径异常 → 静默忽略
2. 确定路径异常 → 正常处理
3. 资源耗尽 → 强制回滚
</code></pre></div>

<h3 id="2253">22.5.3 资源约束</h3>
<ol>
<li><strong>内存开销</strong></li>
</ol>
<p>投机执行的额外内存需求：
$$M_{\text{overhead}} = k \cdot (M_{\text{activation}} + M_{\text{kv_cache}}) + M_{\text{checkpoint}}$$</p>
<ol start="2">
<li><strong>功耗考虑</strong></li>
</ol>
<p>移动端场景的功耗约束：
$$P_{\text{total}} = P_{\text{base}} + k \cdot P_{\text{spec}} \leq P_{\text{budget}}$$</p>
<h2 id="226">22.6 实现考虑</h2>
<h3 id="2261">22.6.1 硬件支持</h3>
<p>不同硬件平台的投机支持能力：</p>
<p>| 平台 | 分支预测 | 事务内存 | 回滚支持 | 适用场景 |</p>
<table>
<thead>
<tr>
<th>平台</th>
<th>分支预测</th>
<th>事务内存</th>
<th>回滚支持</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>GPU (H100)</td>
<td>有限</td>
<td>否</td>
<td>软件实现</td>
<td>大批量投机</td>
</tr>
<tr>
<td>CPU (x86)</td>
<td>强</td>
<td>是 (TSX)</td>
<td>硬件辅助</td>
<td>细粒度投机</td>
</tr>
<tr>
<td>TPU</td>
<td>无</td>
<td>否</td>
<td>软件实现</td>
<td>静态投机</td>
</tr>
<tr>
<td>Mobile GPU</td>
<td>弱</td>
<td>否</td>
<td>软件实现</td>
<td>轻量级投机</td>
</tr>
</tbody>
</table>
<h3 id="2262">22.6.2 编译器集成</h3>
<p>将投机支持集成到编译流程：</p>
<div class="codehilite"><pre><span></span><code>源代码 → 前端分析 → 投机标注 → IR 生成
          ↓
    投机分析 Pass
          ↓
    资源分配 Pass
          ↓
    代码生成 ← 回滚代码注入
</code></pre></div>

<h3 id="2263">22.6.3 运行时系统</h3>
<p>运行时需要提供的支持：</p>
<ol>
<li><strong>投机线程池</strong>：管理投机执行线程</li>
<li><strong>版本管理器</strong>：维护多版本状态</li>
<li><strong>验证器</strong>：高效验证投机结果</li>
<li><strong>性能监控</strong>：动态调整投机策略</li>
</ol>
<h2 id="_3">本章小结</h2>
<p>投机执行是提升 AI 推理性能的重要技术，特别是在大模型推理场景中。本章介绍了：</p>
<ol>
<li><strong>投机解码编译支持</strong>：包括批处理融合、KV cache 管理和内存布局优化</li>
<li><strong>分支预测优化</strong>：静态和动态预测机制，以及多路径投机策略</li>
<li><strong>回滚机制</strong>：状态检查点、回滚策略和内存一致性保证</li>
<li><strong>性能权衡</strong>：投机深度优化、正确性保证和资源约束</li>
</ol>
<p>关键公式回顾：</p>
<ul>
<li>投机收益：$\text{Speedup} = \frac{n \cdot t_{\text{seq}}}{t_{\text{draft}} + t_{\text{verify}} + P_{\text{miss}} \cdot t_{\text{rollback}}}$</li>
<li>最优深度：$k^* = \arg\max_k \left[ \frac{k \cdot p^k}{t_{\text{draft}}(k) + t_{\text{verify}}(k)} \right]$</li>
<li>置信度计算：$\text{Confidence}(\text{path}) = \prod_{b \in \text{path}} P(b) \cdot e^{-\lambda \cdot \text{depth}}$</li>
</ul>
<h2 id="_4">练习题</h2>
<h3 id="_5">基础题</h3>
<p><strong>练习 22.1</strong> 投机深度计算</p>
<p>给定 draft 模型单 token 延迟 5ms，target 模型批量验证 k 个 token 延迟为 $20 + 2k$ ms，预测准确率 0.8，计算最优投机深度。</p>
<p><em>Hint</em>：使用收益函数 $\text{Benefit}(k) = \frac{k \cdot 0.8^k}{5k + 20 + 2k}$</p>
<details>
<summary>参考答案</summary>
<p>求导并令其为零：
$$\frac{d}{dk}\left[\frac{k \cdot 0.8^k}{7k + 20}\right] = 0$$
数值求解得 $k^* \approx 4$</p>
<p>验证：</p>
<ul>
<li>$k=3$: Benefit = 0.048</li>
<li>$k=4$: Benefit = 0.049</li>
<li>$k=5$: Benefit = 0.046</li>
</ul>
<p>因此最优投机深度为 4。</p>
</details>
<p><strong>练习 22.2</strong> 回滚概率分析</p>
<p>如果单步预测准确率为 p，计算投机 k 步后至少需要回滚 m 步的概率。</p>
<p><em>Hint</em>：这是一个几何分布问题</p>
<details>
<summary>参考答案</summary>
<p>需要回滚 m 步意味着第 (k-m+1) 步预测错误：
$$P(\text{rollback} \geq m) = p^{k-m} \cdot (1-p)$$
对于完全成功（无需回滚）：
$$P(\text{no rollback}) = p^k$$
期望回滚步数：
$$E[\text{rollback}] = k - \frac{p(1-p^k)}{1-p}$$</p>
</details>
<p><strong>练习 22.3</strong> 内存开销估算</p>
<p>某 LLM 模型每个 token 的 KV cache 占用 2MB，激活值占用 1MB。若支持 8 路并行投机，每路投机深度 4，计算额外内存开销。</p>
<p><em>Hint</em>：考虑所有投机路径的存储需求</p>
<details>
<summary>参考答案</summary>
<p>每条投机路径需要：</p>
<ul>
<li>KV cache: 4 × 2MB = 8MB</li>
<li>激活值: 4 × 1MB = 4MB</li>
<li>小计: 12MB</li>
</ul>
<p>8 路并行：</p>
<ul>
<li>总开销: 8 × 12MB = 96MB</li>
</ul>
<p>加上检查点（假设 10MB）：</p>
<ul>
<li>总计: 96MB + 10MB = 106MB</li>
</ul>
</details>
<h3 id="_6">挑战题</h3>
<p><strong>练习 22.4</strong> 多级投机设计</p>
<p>设计一个两级投机系统：使用 tiny 模型（1ms/token）投机 8 个 token，draft 模型（5ms/token）验证并投机 4 个，最后 target 模型（30ms/batch）验证。分析其性能特性。</p>
<p><em>Hint</em>：建立多级投机的性能模型</p>
<details>
<summary>参考答案</summary>
<p>两级投机的执行流程：</p>
<ol>
<li>Tiny 模型生成：8 × 1ms = 8ms</li>
<li>Draft 模型验证 tiny 并生成：
   - 验证 tiny：假设批量 10ms
   - 生成新 token：4 × 5ms = 20ms
   - 小计：30ms</li>
<li>Target 模型最终验证：30ms</li>
</ol>
<p>总延迟：68ms</p>
<p>有效 token 数期望（假设 tiny 准确率 0.6，draft 准确率 0.8）：</p>
<ul>
<li>Tiny 接受：$8 \times 0.6 = 4.8$</li>
<li>Draft 接受：$4 \times 0.8 = 3.2$</li>
<li>总计：约 8 个 token</li>
</ul>
<p>吞吐量：8 / 68ms ≈ 118 tokens/s</p>
<p>相比顺序执行（30ms/token = 33 tokens/s），加速比约 3.6x。</p>
</details>
<p><strong>练习 22.5</strong> 自适应投机策略</p>
<p>设计一个根据运行时统计自动调整投机深度和资源分配的算法。考虑：预测准确率、系统负载、延迟要求。</p>
<p><em>Hint</em>：使用控制论方法或强化学习框架</p>
<details>
<summary>参考答案</summary>
<p>自适应算法框架：</p>
<div class="codehilite"><pre><span></span><code><span class="n">State</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">accuracy_history</span><span class="p">,</span><span class="w"> </span><span class="nb">load</span><span class="p">,</span><span class="w"> </span><span class="n">latency_target</span><span class="p">}</span>
<span class="n">Action</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">spec_depth</span><span class="p">,</span><span class="w"> </span><span class="n">resource_split</span><span class="p">}</span>

<span class="mf">1.</span><span class="w"> </span><span class="err">监控阶段（每</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="err">次推理）：</span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="err">统计平均准确率</span><span class="w"> </span><span class="n">p_avg</span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="err">测量系统负载</span><span class="w"> </span><span class="nb">load</span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="err">计算延迟违约率</span><span class="w"> </span><span class="n">violation_rate</span>

<span class="mf">2.</span><span class="w"> </span><span class="err">决策阶段：</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="n">violation_rate</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.1</span><span class="p">:</span>
<span class="w">       </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">  </span><span class="c1"># 降低投机深度</span>
<span class="w">       </span><span class="n">r_draft</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mf">0.9</span><span class="w">      </span><span class="c1"># 减少 draft 资源</span>
<span class="w">   </span><span class="k">elif</span><span class="w"> </span><span class="n">p_avg</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.85</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="nb">load</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.7</span><span class="p">:</span>
<span class="w">       </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">min</span><span class="p">(</span><span class="n">k_max</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">  </span><span class="c1"># 增加投机深度</span>
<span class="w">       </span><span class="n">r_draft</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mf">1.1</span><span class="w">          </span><span class="c1"># 增加 draft 资源</span>

<span class="mf">3.</span><span class="w"> </span><span class="err">资源再平衡：</span>
<span class="w">   </span><span class="n">r_target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r_draft</span>
<span class="w">   </span><span class="err">确保</span><span class="w"> </span><span class="n">r_draft</span><span class="w"> </span><span class="err">∈</span><span class="w"> </span><span class="p">[</span><span class="mf">0.2</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5</span><span class="p">]</span>

<span class="mf">4.</span><span class="w"> </span><span class="err">性能预测：</span>
<span class="w">   </span><span class="n">expected_speedup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p_avg</span><span class="o">^</span><span class="n">k</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">r_draft</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r_target</span><span class="p">)</span>

<span class="mf">5.</span><span class="w"> </span><span class="err">反馈学习：</span>
<span class="w">   </span><span class="err">使用</span><span class="w"> </span><span class="n">EMA</span><span class="w"> </span><span class="err">更新历史统计</span>
</code></pre></div>

</details>
<p><strong>练习 22.6</strong> 分布式投机</p>
<p>在多 GPU 环境中，设计一个分布式投机执行方案。考虑：通信开销、负载均衡、一致性保证。</p>
<p><em>Hint</em>：将投机任务映射到不同 GPU</p>
<details>
<summary>参考答案</summary>
<p>分布式投机架构：</p>
<ol>
<li>
<p><strong>任务分配</strong>：
   - GPU 0：运行 target 模型（主节点）
   - GPU 1-3：运行 draft 模型的不同投机分支
   - GPU 4-7：运行 tiny 模型的更深层投机</p>
</li>
<li>
<p><strong>通信模式</strong>：</p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="nv">Ring</span><span class="w"> </span><span class="nv">AllReduce</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">verification</span><span class="w"> </span><span class="nv">results</span>
<span class="nv">Point</span><span class="o">-</span><span class="nv">to</span><span class="o">-</span><span class="nv">Point</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">speculation</span><span class="w"> </span><span class="nv">candidates</span>
</code></pre></div>

<ol start="3">
<li>
<p><strong>一致性协议</strong>：
   - 使用逻辑时钟标记投机版本
   - 两阶段提交确认接受的 token</p>
</li>
<li>
<p><strong>负载均衡</strong>：</p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">Load</span><span class="p">(</span><span class="n">GPU_i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">α</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">compute_load</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">β</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">memory_load</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">γ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">comm_load</span>

<span class="err">动态迁移策略：</span>
<span class="k">if</span><span class="w"> </span><span class="n">Load</span><span class="p">(</span><span class="n">GPU_i</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Load_avg</span><span class="p">:</span>
<span class="w">    </span><span class="n">migrate_task</span><span class="p">(</span><span class="n">GPU_i</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">least_loaded_GPU</span><span class="p">)</span>
</code></pre></div>

<ol start="5">
<li><strong>性能模型</strong>：
$$T_{distributed} = \max_i(T_{compute,i}) + T_{comm} + T_{sync}$$
其中通信时间：
$$T_{comm} = \frac{n_{tokens} \times size_{embedding}}{bandwidth} + latency$$</li>
</ol>
</details>
<p><strong>练习 22.7</strong> 混合精度投机</p>
<p>设计一个投机执行系统，draft 模型使用 INT8，target 模型使用 FP16。分析精度损失对投机成功率的影响。</p>
<p><em>Hint</em>：建立精度-准确率模型</p>
<details>
<summary>参考答案</summary>
<p>混合精度投机分析：</p>
<ol>
<li>
<p><strong>精度影响模型</strong>：
$$p_{INT8} = p_{FP16} \times (1 - \epsilon_{quant})$$
其中 $\epsilon_{quant} \approx 0.1$ 到 $0.15$</p>
</li>
<li>
<p><strong>投机策略调整</strong>：
   - 降低投机深度：$k_{INT8} = \lfloor 0.8 \times k_{FP16} \rfloor$
   - 提高验证阈值：降低假阳性</p>
</li>
<li>
<p><strong>性能权衡</strong>：</p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code>Speedup_INT8 = 2x (计算加速)
Accuracy_loss = 10-15%

Net benefit = Speedup_INT8 <span class="gs">* (1 - Accuracy_loss)</span>
<span class="gs">             = 2 *</span> 0.85 = 1.7x
</code></pre></div>

<ol start="4">
<li>
<p><strong>自适应量化</strong>：
   - 对高置信度预测使用 INT8
   - 对低置信度预测使用 FP16</p>
</li>
<li>
<p><strong>误差累积分析</strong>：
$$Error_{total} = \sum_{i=1}^{k} \epsilon_i \times 2^{i-1}$$</p>
</li>
</ol>
<p>需要限制投机深度防止误差爆炸。</p>
</details>
<h2 id="_7">常见陷阱与错误</h2>
<h3 id="1">1. 过度投机</h3>
<p><strong>问题</strong>：投机深度过大导致资源浪费和性能下降</p>
<p><strong>解决</strong>：</p>
<ul>
<li>实施自适应深度控制</li>
<li>监控投机成功率</li>
<li>设置资源使用上限</li>
</ul>
<h3 id="2">2. 回滚开销被低估</h3>
<p><strong>问题</strong>：频繁回滚导致性能严重下降</p>
<p><strong>解决</strong>：</p>
<ul>
<li>准确建模回滚成本</li>
<li>实现轻量级检查点</li>
<li>使用增量状态保存</li>
</ul>
<h3 id="3">3. 内存一致性违反</h3>
<p><strong>问题</strong>：投机写入污染主内存</p>
<p><strong>解决</strong>：</p>
<ul>
<li>严格的 write buffer 管理</li>
<li>版本化存储机制</li>
<li>完整的提交协议</li>
</ul>
<h3 id="4">4. 资源竞争</h3>
<p><strong>问题</strong>：投机执行与主执行争抢资源</p>
<p><strong>解决</strong>：</p>
<ul>
<li>资源预留策略</li>
<li>优先级调度</li>
<li>动态资源分配</li>
</ul>
<h3 id="5">5. 调试困难</h3>
<p><strong>问题</strong>：投机执行使调试变得复杂</p>
<p><strong>解决</strong>：</p>
<ul>
<li>提供非投机执行模式</li>
<li>完整的执行日志</li>
<li>确定性重放支持</li>
</ul>
<h2 id="_8">最佳实践检查清单</h2>
<h3 id="_9">设计阶段</h3>
<ul>
<li>[ ] 明确投机执行的适用场景</li>
<li>[ ] 评估硬件平台的投机支持能力</li>
<li>[ ] 设计完整的回滚机制</li>
<li>[ ] 考虑内存和功耗约束</li>
<li>[ ] 制定性能评估指标</li>
</ul>
<h3 id="_10">实现阶段</h3>
<ul>
<li>[ ] 实现高效的状态检查点</li>
<li>[ ] 优化投机路径的资源分配</li>
<li>[ ] 确保内存一致性</li>
<li>[ ] 添加性能监控点</li>
<li>[ ] 实现自适应策略</li>
</ul>
<h3 id="_11">优化阶段</h3>
<ul>
<li>[ ] Profile 投机成功率</li>
<li>[ ] 调优投机深度</li>
<li>[ ] 优化验证批处理</li>
<li>[ ] 减少回滚开销</li>
<li>[ ] 平衡资源使用</li>
</ul>
<h3 id="_12">测试阶段</h3>
<ul>
<li>[ ] 验证正确性保证</li>
<li>[ ] 测试极端场景</li>
<li>[ ] 评估性能提升</li>
<li>[ ] 检查资源使用</li>
<li>[ ] 确认调试支持</li>
</ul>
<h3 id="_13">部署阶段</h3>
<ul>
<li>[ ] 监控运行时统计</li>
<li>[ ] 收集用户反馈</li>
<li>[ ] 持续优化策略</li>
<li>[ ] 更新性能模型</li>
<li>[ ] 维护版本兼容性</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="chapter21.html" class="nav-link prev">← 第 21 章：高维张量别名分析</a><a href="chapter23.html" class="nav-link next">第 23 章：自动驾驶场景优化 →</a></nav>
        </main>
    </div>
</body>
</html>